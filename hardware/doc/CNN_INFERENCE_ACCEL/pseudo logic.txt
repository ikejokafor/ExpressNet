
// MapSize will be a power of 2, so comparison of last bits are zero can be used
// Kernel Module Depth Size will always be greater than or equal to largest Input Depth Size
//old
if(dataIsValid)

	addr_inc = 0
	
	while(dataIsValid):

		if(inputAddr % MapSize == 0):
		
			outputAddr 	= inputAddr + addr_inc
			
			startAddr 	= outputAddr
			
			addr_inc++
			
		else
		
			outputAddr 	= startAddr + layerDepthSize
			
			startAddr	= outputAddr
			
else

	addr_inc = 0
	
// final 
if(dataIsValid):

	while(dataIsValid):
	
		outputAddr = inputAddr * layerDepthSize










	if(dataIsValid):

		firstColPixelAddr = 0
		
		while(dataIsValid):

			if(inputAddr % ColSize == 0):
			
				outputAddr			= firstPixelColAddr
				
				currentColOffset 	= outputAddr
				
				firstPixelColAddr++
				
			else:
			
				outputAddr 			= currentColOffset + RowSize
				
				currentColOffset	= outputAddr
				
	else:

		firstPixelColAddr = 0
	
	
	



	while(dataIsValid):

		if(currentPacketDepth < layerDepth && currentPacketDepth < kernelModuleDepth):
			
			-> Concat_previous_segment	// if any
			
			while((currentPacketDepth + packetDepth) < layerDepth):
			
				-> Next_Pixel_Packet
				-> Segment_Packet		// if necessary 
				-> Concat_segment
					
			-> Zero_Pad					// if necessary
			-> Send_Pixel_Packet
		
		else if(currentPacketDepth > layerDepth && currentPacketDepth < kernelModuleDepth):
		
			-> Segment_Packet
			-> Zero_Pad
			-> Send_Pixel_Packet
		
		else if(currentPacketDepth == layerDepth && currentPacketDepth < kernelModuleDepth):
		
			-> Zero_Pad
			-> Send_Pixel_Packet
				
		else if(currentPacketDepth == layerDepth && currentPacketDepth == kernelModuleDepth):
		
			-> Send_Pixel_Packet
			
		
		
